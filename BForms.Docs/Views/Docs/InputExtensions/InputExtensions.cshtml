@using BForms.Docs.Helpers
@{
    ViewBag.Title = "Input controls";
}

<div class="row">
    
    <div class="hidden-xs hidden-sm col-md-3 col-lg-3">
        
        <div class="bs-sidebar">
            <ul class="nav bs-sidenav">
                <li>
                    <a href="#input-section">Input elements</a>
                    <ul class="nav">
                        <li><a href="#Input">Input helper</a></li>
                        <li><a href="#Input-Textbox">Textbox</a></li>
                        <li><a href="#Input-Password">Password</a></li>
                        <li><a href="#Input-Email">Email</a></li>
                        <li><a href="#Input-Url">Url</a></li>
                        <li><a href="#Input-Number">Number</a></li>
                        <li><a href="#Input-Checkbox">Checkbox</a></li>
                        <li><a href="#Input-Radio">Radio button</a></li>
                        <li><a href="#Input-DatePicker">Date & Datetime picker</a></li>
                        <li><a href="#Input-TimePicker">Time picker</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <main class="col-md-9 col-lg-9" role="main">
        <div class="bs-docs-section">
            <div class="page-header">
                <h1 id="input-section">Inputs</h1>
            </div>
            <p>
                BForms exposes two ways of building input elements using Razor HTML extension methods: the first way of doing this is through the <code>BsControlAttribute</code> in combination with 
                <code>BsInputFor</code> helper, the <code>BsInputFor</code> will render the specified input type based on the selected value of the <code>BsControlType</code> enum. 
                Another way is to use a specialized helpers like <code>BsTextBoxFor</code>, <code>BsTextAreaFor</code> and so on.
            </p>
            <p>
                We recommend you use the generic <code>BsInputFor</code> helper, this declarative approach makes the Model the place where you can decide the behavior of your form. 
                When you need to change the output of a certain model property all you need to do is change the <code>BsControlType</code> designated for that property 
                 - this way you don't have to modify the view at all.
            </p>
            <p>
                In ASP.NET MVC the behavior of a certain property is determined by mixing attributes like <code>Description</code>, <code>DataType</code> and <code>Required</code> 
                with specialized helpers like <code>TextBoxFor</code>. BFroms tries to simplify this process by only using attributes and a generic helper. 
                In order to maintain compatibility with MVC, BForms will expose the same specialized helpers as MVC does, so if you don’t like the declarative approach 
                you can still use BForms.
            </p>

            <h4 class="sub_title">Input Extensions</h4>
<pre class="prettyprint lang-cs bs-example">
@Html.InsertFileContentCached("~/Views/Docs/InputExtensions/Source/AllInputExtensions.cs.embed")
</pre>

            @Html.Partial("InputExtensions/_InputHelper")
            @Html.Partial("InputExtensions/_InputTextbox")
            @Html.Partial("InputExtensions/_InputPassword")
            @Html.Partial("InputExtensions/_InputEmail")
            @Html.Partial("InputExtensions/_InputUrl")
            @Html.Partial("InputExtensions/_InputNumber")
            @Html.Partial("InputExtensions/_InputCheckbox")
            @Html.Partial("InputExtensions/_InputRadio")
            @Html.Partial("InputExtensions/_InputDatePicker")
            @Html.Partial("InputExtensions/_InputTimePicker")
        </div>
    </main>

</div>